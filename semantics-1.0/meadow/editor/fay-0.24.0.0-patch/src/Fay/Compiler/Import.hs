{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE TupleSections     #-}
{-# LANGUAGE ViewPatterns      #-}

-- | Handles finding imports and compiling them recursively.
-- This is done for each full AST traversal the copmiler does
-- which at this point is InitialPass's preprocessing
-- and Compiler's code generation
module Fay.Compiler.Import
  ( startCompile
  , startCompileText
  , compileWith
  , compileWithPre
  ) where

import           Fay.Compiler.Prelude

import           Fay.Compiler.Misc
import           Fay.Compiler.Parse
import           Fay.Config
import qualified Fay.Exts                        as F
import           Fay.Exts.NoAnnotation           (unAnn)
import           Fay.Types

import           Control.Monad.Except            (throwError)
import           Control.Monad.RWS               (ask, get, gets, lift, listen, modify)
import           Language.Haskell.Exts hiding (name)
import           System.Directory
import           System.FilePath
import           Language.Haskell.Names.Types
import System.IO.Unsafe (unsafePerformIO)
import GHCJS.Types (JSVal)
import Data.JSString (JSString, pack, unpack)
import GHCJS.Foreign (fromJSBool, toJSBool)
import GHCJS.Foreign.Callback (Callback, asyncCallback)


foreign import javascript safe
   "textarea.setValue(textarea.getValue() + '\\n' + $1);"
   logAux :: JSString -> IO ()
logThis a b = unsafePerformIO $ do
                logAux (pack a)
                return b


-- | Start the compilation process using `compileModule` to compile a file.
startCompile :: Show a => (FilePath -> String -> Compile a) -> FilePath -> Compile a
startCompile compileModule filein = do
  modify $ \s -> s { stateImported = [] }
  fmap fst . listen $ compileModuleFromFile compileModule filein

startCompileText :: Show a => (FilePath -> String -> Compile a) -> FilePath -> String -> Compile a
startCompileText compileModule filein string = do
  modify $ \s -> s { stateImported = [] }
  compileModule filein string

-- | Compile a module
compileWithPre
  :: FilePath
  -> (() -> F.Module -> Compile ())
  -> (FilePath -> String -> Compile ())
  -> (F.X -> F.Module -> IO (Either CompileError F.Module))
  -> String
  -> Compile ((), CompileState, CompileWriter)
compileWithPre filepath with compileModule before from = 
  logThis ("Preprocessing \"" ++ filepath ++ "\" ...") (compileWith2 filepath with compileModule before from)


compileWith
  :: Monoid a => Show a
  => FilePath
  -> (a -> F.Module -> Compile a)
  -> (FilePath -> String -> Compile a)
  -> (F.X -> F.Module -> IO (Either CompileError F.Module))
  -> String
  -> Compile (a, CompileState, CompileWriter)
compileWith filepath with compileModule before from =
  logThis ("Compiling \"" ++ filepath ++ "\" ...") (compileWith2 filepath with compileModule before from)
 
compileWith2
  :: Monoid a => Show a
  => FilePath
  -> (a -> F.Module -> Compile a)
  -> (FilePath -> String -> Compile a)
  -> (F.X -> F.Module -> IO (Either CompileError F.Module))
  -> String
  -> Compile (a, CompileState, CompileWriter)
compileWith2 filepath with compileModule before from = do
  rd <- ask
  st <- get
  res <- Compile . lift . lift $
             runCompileModule rd st
                  (parseResult (throwError . uncurry ParseError)
                   (\mod' -> do
                     mod@(Module _ _ _ imports _) <-
                       either throwError return =<< io (before F.noI mod')
                     res <- foldr (<>) mempty <$> mapM (compileImport compileModule) imports
                     modify $ \s -> s { stateModuleName = unAnn $ F.moduleName mod }
                     with res mod
                   )
                   (parseFay filepath from))
  either throwError return res

-- | Compile a module given its file path
compileModuleFromFile
  :: Show a => (FilePath -> String -> Compile a)
  -> FilePath
  -> Compile a
compileModuleFromFile compileModule fp = io (readFile fp) >>= compileModule fp

-- | Lookup a module from include directories and compile.
compileModuleFromName
  :: Show a => Monoid a
  => (FilePath -> String -> Compile a)
  -> F.ModuleName
  -> Compile a
compileModuleFromName compileModule nm =
  unlessImported nm compileModule
    where
      unlessImported
        :: Monoid a
        => ModuleName l
        -> (FilePath -> String -> Compile a)
        -> Compile a
      unlessImported (ModuleName _ "Fay.Types") _ = return mempty
      unlessImported (unAnn -> name) importIt = do
        imported <- gets stateImported
        case lookup name imported of
          Just _  -> return mempty
          Nothing -> do
            dirs <- configDirectoryIncludePaths <$> config id
            (filepath,contents) <- findImport dirs name
            modify $ \s -> s { stateImported = (name,filepath) : imported }
            importIt filepath contents

-- | Compile an import.
compileImport
  :: Show a => Monoid a
  => (FilePath -> String -> Compile a)
  -> F.ImportDecl
  -> Compile a
compileImport compileModule i = case i of
  -- Trickery in fay-base needs this special case
  ImportDecl _ _    _ _ _ (Just "base") _ _ -> return mempty
  ImportDecl _ name _ _ _ _ _ _ -> compileModuleFromName compileModule name

-- | Find an import's filepath and contents from its module name.
findImport :: [FilePath] -> ModuleName a -> Compile (FilePath,String)
findImport alldirs (unAnn -> mname) = go alldirs mname where
  go :: [FilePath] -> ModuleName a -> Compile (FilePath,String)
  go _ (ModuleName _ "Fay.FFI") = return ("Fay/FFI.hs", "module Fay.FFI where\n\ndata Nullable a = Nullable a | Null\n\ndata Defined a = Defined a | Undefined")
  go _ (ModuleName _ "Types") = return ("Fay/Types.hs", "newtype Fay a = Fay (Identity a)\n\nnewtype Identity a = Identity a")
  go _ (ModuleName _ "Data.Data") = return ("Data/Data.hs", "{-# LANGUAGE PackageImports #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE CPP #-}\nmodule Data.Data\n#ifndef FAY\n  (Data,Typeable)\n#endif\n  where\n\nimport \"base\" Data.Data\n")
  go _ (ModuleName _ "Prelude") = return ("Prelude.hs", "{-# LANGUAGE CPP                  #-}\n{-# LANGUAGE FlexibleInstances    #-}\n{-# LANGUAGE PackageImports       #-}\n{-# LANGUAGE TypeSynonymInstances #-}\n{-# OPTIONS -fno-warn-missing-methods #-}\n\nmodule Prelude\n  (\n  -- Prelude type re-exports\n   Base.Char\n  ,Base.String\n  ,Base.Double\n  ,Base.Int\n  ,Base.Integer\n  ,Base.Bool(..)\n  ,Base.Read\n  ,Base.Show\n  ,Base.Eq\n  ,(==)\n  ,(/=)\n  -- Standard data types\n  ,Maybe(..)\n  ,maybe\n  -- Monads\n  ,(>>=)\n  ,(>>)\n  ,return\n  ,fail\n  ,when\n  ,unless\n  ,forM\n  ,forM_\n  ,mapM\n  ,mapM_\n  ,(=<<)\n  ,sequence\n  ,sequence_\n  ,void\n  ,(>=>)\n  ,(<=<)\n  -- Num\n  ,(*)\n  ,(+)\n  ,(-)\n  -- Ord\n  ,Ord\n  ,Ordering(..)\n  -- An ordering.\n  ,(<)\n  ,(<=)\n  ,(>)\n  ,(>=)\n  ,compare\n  -- Enum\n  ,succ\n  ,pred\n  ,enumFrom\n  ,enumFromTo\n  ,enumFromBy\n  ,enumFromThen\n  ,enumFromByTo\n  ,enumFromThenTo\n  -- Fractional\n  ,(/)\n  -- Integral\n  ,fromIntegral\n  ,fromInteger\n  -- Bools\n  ,(&&)\n  ,(||)\n  ,not\n  ,otherwise\n  -- Show\n  ,show\n  -- Errors\n  ,error\n  ,undefined\n  ,Either(..)\n  ,either\n  -- Functions\n  ,until\n  ,($!)\n  ,seq\n  ,const\n  ,id\n  ,(.)\n  ,($)\n  ,flip\n  ,curry\n  ,uncurry\n  ,snd\n  ,fst\n  -- Numbers\n  ,div\n  ,mod\n  ,divMod\n  ,min\n  ,max\n  ,recip\n  ,negate\n  ,abs\n  ,signum\n  ,pi\n  ,exp\n  ,sqrt\n  ,log\n  ,(**)\n  ,(^^)\n  ,unsafePow\n  ,(^)\n  ,logBase\n  ,sin\n  ,tan\n  ,cos\n  ,asin\n  ,atan\n  ,acos\n  ,sinh\n  ,tanh\n  ,cosh\n  ,asinh\n  ,atanh\n  ,acosh\n  ,properFraction\n  ,truncate\n  ,round\n  ,ceiling\n  ,floor\n  ,subtract\n  ,even\n  ,odd\n  ,gcd\n  ,quot\n  ,quot'\n  ,quotRem\n  ,rem\n  ,rem'\n  ,lcm\n  -- Lists\n  ,find\n  ,filter\n  ,null\n  ,map\n  ,nub\n  ,nub'\n  ,elem\n  ,notElem\n  ,sort\n  ,sortBy\n  ,insertBy\n  ,conc\n  ,concat\n  ,concatMap\n  ,foldr\n  ,foldr1\n  ,foldl\n  ,foldl1\n  ,(++)\n  ,(!!)\n  ,head\n  ,tail\n  ,init\n  ,last\n  ,iterate\n  ,repeat\n  ,replicate\n  ,cycle\n  ,take\n  ,drop\n  ,splitAt\n  ,takeWhile\n  ,dropWhile\n  ,span\n  ,break\n  ,zipWith\n  ,zipWith3\n  ,zip\n  ,zip3\n  ,unzip\n  ,unzip3\n  ,lines\n  ,unlines\n  ,words\n  ,unwords\n  ,and\n  ,or\n  ,any\n  ,all\n  ,intersperse\n  ,prependToAll\n  ,intercalate\n  ,maximum\n  ,minimum\n  ,product\n  ,sum\n  ,scanl\n  ,scanl1\n  ,scanr\n  ,scanr1\n  ,lookup\n  ,length\n  ,length'\n  ,reverse\n  -- IO\n  ,print\n  ,putStrLn\n  ,ifThenElse\n  ,Fay\n  )\n  where\n\n#ifdef FAY\nimport           Data.Data\n#endif\nimport           Fay.FFI\nimport           \"base\" Prelude   (Bool (True, False), Eq, seq, (&&), (/=),\n                                   (==), (||))\nimport qualified \"base\" Prelude   as Base\n#ifndef FAY\nimport           \"base\" Prelude   (Either (..), Maybe (..), Ordering (..))\n#endif\n\n--------------------------------------------------------------------------------\n-- Fixities\n\ninfixr 9  .\ninfixr 8  ^, ^^, **\ninfixl 7  *, /, `quot`, `rem`, `div`, `mod`\ninfixl 6  +, -\n\n-- The (:) operator is built-in syntax, and cannot legally be given\n-- a fixity declaration; but its fixity is given by:\n--   infixr 5  :\n\n-- Provided by base prelude\n--   infix  4  ==, /=\n--   infixr 3  &&\n--   infixr 2  ||\n--   infixr 0  $, $!\n\ninfixr 4  <, <=, >=, >\ninfixl 1  >>, >>=\ninfixr 1  =<<, >=>, <=<\ninfixr 0  $, $!\n\n-- PreludeList\n\ninfixl 9  !!\ninfixr 5  ++\ninfix  4  `elem`, `notElem`\n\n--------------------------------------------------------------------------------\n-- Aliases of base\n\ntype Char    = Base.Char\ntype Double  = Base.Double\ntype Int     = Base.Int\ntype Integer = Base.Integer\ntype String  = Base.String\n\n--------------------------------------------------------------------------------\n-- Standard data types\n\n-- | Maybe type.\n#ifdef FAY\ndata Maybe a = Just a | Nothing\ninstance Base.Read a => Base.Read (Maybe a)\ninstance Base.Show a => Base.Show (Maybe a)\ninstance Typeable a => Typeable (Maybe a)\ninstance Data a => Data (Maybe a)\n#endif\n\n-- | Either type.\n#ifdef FAY\ndata Either a b = Left a | Right b\n#endif\n\nmaybe :: t -> (t1 -> t) -> Maybe t1 -> t\nmaybe m _ Nothing = m\nmaybe _ f (Just x) = f x\n\n--------------------------------------------------------------------------------\n-- Monads\n\n-- | Monomorphic bind for Fay.\n(>>=) :: Ptr (Fay a) -> Ptr (a -> Fay b) -> Ptr (Fay b)\n(>>=) = ffi \"Fay$$_(Fay$$bind(%1)(%2))\"\n\n-- | Monomorphic then for Fay.\n(>>) :: Ptr (Fay a) -> Ptr (Fay b) -> Ptr (Fay b)\n(>>) = ffi \"Fay$$_(Fay$$then(%1)(%2))\"\n\n-- | Monomorphic return for Fay.\nreturn :: a -> Fay a\nreturn = ffi \"Fay$$$_return(%1)\"\n\nfail :: String -> Fay a\nfail = error\n\nwhen :: Bool -> Fay () -> Fay ()\nwhen p m = if p then m else return ()\n\nunless :: Bool -> Fay () -> Fay ()\nunless p m = if p then return () else m\n\nforM :: [a] -> (a -> Fay b) -> Fay [b]\nforM lst fn = sequence $ map fn lst\n\nforM_ :: [a] -> (a -> Fay b) -> Fay ()\nforM_ (x:xs) m = m x >> forM_ xs m\nforM_ []     _ = return ()\n\nmapM :: (a -> Fay b) -> [a] -> Fay [b]\nmapM fn lst = sequence $ map fn lst\n\nmapM_ :: (a -> Fay b) -> [a] -> Fay ()\nmapM_ m (x:xs) = m x >> mapM_ m xs\nmapM_ _ []     = return ()\n\n(=<<) :: (a -> Fay b) -> Fay a -> Fay b\nf =<< x = x >>= f\n\nvoid :: Fay a -> Fay ()\nvoid f = f >> return ()\n\n(>=>) :: (a -> Fay b) -> (b -> Fay c) -> a -> Fay c\n(>=>) f g x = f x >>= g\n\n(<=<) :: (b -> Fay c) -> (a -> Fay b) -> a -> Fay c\n(<=<) g f x = f x >>= g\n\n-- | Evaluate each action in the sequence from left to right,\n-- and collect the results.\nsequence :: [Fay a] -> Fay [a]\nsequence ms = foldr k (return []) ms\n            where\n              k m m' = do { x <- m; xs <- m'; return (x:xs) }\n\nsequence_ :: [Fay a] -> Fay ()\nsequence_ []     = return ()\nsequence_ (m:ms) = m >> sequence_ ms\n\n--------------------------------------------------------------------------------\n-- Num\n\nclass Base.Num a => Num a where\n  (*) :: a -> a -> a\n  (+) :: a -> a -> a\n  (-) :: a -> a -> a\n\ninstance Num Int\ninstance Num Double\n\n--------------------------------------------------------------------------------\n-- Ord\n\n-- An ordering.\n#ifdef FAY\ndata Ordering = GT | LT | EQ\n#endif\n\nclass (Eq a) => Ord a where\n  (<)  :: a -> a -> Bool\n  (<=) :: a -> a -> Bool\n  (>)  :: a -> a -> Bool\n  (>=) :: a -> a -> Bool\n\ninstance Ord Char\ninstance Ord Double\ninstance Ord Int\ninstance Ord Integer\n\ncompare :: Ord a => a -> a -> Ordering\ncompare x y =\n  if x > y\n     then GT\n     else if x < y\n             then LT\n             else EQ\n\n--------------------------------------------------------------------------------\n-- Enum\n\nclass (Base.Enum a) => Enum a where\n\ninstance Enum Int\n-- Integers are represented as JS numbers which aren't arbitrary precision\n-- se we shouldn't add an Enum instance.\n\nsucc :: Num a => a -> a\nsucc x = x + 1\n\npred :: Num a => a -> a\npred x = x - 1\n\nenumFrom :: Num a => a -> [a]\nenumFrom i = i : enumFrom (i + 1)\n\nenumFromTo :: (Ord t, Num t) => t -> t -> [t]\nenumFromTo i n =\n  if i > n then [] else i : enumFromTo (i + 1) n\n\nenumFromBy :: (Num t) => t -> t -> [t]\nenumFromBy fr by = fr : enumFromBy (fr + by) by\n\nenumFromThen :: (Num t) => t -> t -> [t]\nenumFromThen fr th = enumFromBy fr (th - fr)\n\nenumFromByTo :: (Ord t, Num t) => t -> t -> t -> [t]\nenumFromByTo fr by to = if by < 0 then neg fr else pos fr\n  where neg x = if x < to then [] else x : neg (x + by)\n        pos x = if x > to then [] else x : pos (x + by)\n\nenumFromThenTo :: (Ord t, Num t) => t -> t -> t -> [t]\nenumFromThenTo fr th to = enumFromByTo fr (th - fr) to\n\n--------------------------------------------------------------------------------\n-- Fractional\n\nclass (Num a,Base.Fractional a) => Fractional a where\n  (/) :: a -> a -> a\n\ninstance Fractional Double\n\n--------------------------------------------------------------------------------\n-- Integral\n\nclass (Enum a,Base.Integral a) => Integral a\n\ninstance Integral Int\n-- Can't add Integer instance since Integer isn't an Enum (see Enum above).\n\nfromIntegral :: (Num a, Num b) => Ptr a -> Ptr b\nfromIntegral = ffi \"%1\"\n\nfromInteger :: Num a => Ptr Integer -> Ptr a\nfromInteger = ffi \"%1\"\n\n--------------------------------------------------------------------------------\n-- Bools\n\nnot :: Bool -> Bool\nnot p = if p then False else True\n\notherwise :: Bool\notherwise = True\n\n--------------------------------------------------------------------------------\n-- Show\n\n-- | Uses JSON.stringify.\nshow :: Automatic a -> String\nshow = ffi \"JSON.stringify(%1)\"\n\n--------------------------------------------------------------------------------\n-- Errors\n\n-- | Throws a JavaScript error.\nerror :: String -> a\nerror = ffi \"(function() { throw %1 })()\"\n\n-- | Throws \"undefined\" via \"error\".\nundefined :: a\nundefined = error \"Prelude.undefined\"\n\neither :: (a -> c) -> (b -> c) -> Either a b -> c\neither f _ (Left a) = f a\neither _ g (Right b) = g b\n\n--------------------------------------------------------------------------------\n-- Functions\n\nuntil :: (a -> Bool) -> (a -> a) -> a -> a\nuntil p f x = if p x then x else until p f (f x)\n\n($!) :: (a -> b) -> a -> b\nf $! x = x `seq` f x\n\nconst :: a -> b -> a\nconst a _ = a\n\nid :: a -> a\nid x = x\n\n(.) :: (t1 -> t) -> (t2 -> t1) -> t2 -> t\n(f . g) x = f (g x)\n\n($) :: (t1 -> t) -> t1 -> t\nf $ x = f x\n\nflip :: (t1 -> t2 -> t) -> t2 -> t1 -> t\nflip f x y = f y x\n\ncurry :: ((a, b) -> c) -> a -> b -> c\ncurry f x y = f (x, y)\n\nuncurry :: (a -> b -> c) -> (a, b) -> c\nuncurry f p = case p of (x, y) -> f x y\n\nsnd :: (t, t1) -> t1\nsnd (_,x) = x\n\nfst :: (t, t1) -> t\nfst (x,_) = x\n\n--------------------------------------------------------------------------------\n-- Numbers\n\ndiv :: Int -> Int -> Int\ndiv x y\n  | x > 0 && y < 0 = quot (x-1) y - 1\n  | x < 0 && y > 0 = quot (x+1) y - 1\ndiv x y            = quot x y\n\nmod :: Int -> Int -> Int\nmod x y\n  | x > 0 && y < 0 = rem (x-1) y + y + 1\n  | x < 0 && y > 0 = rem (x+1) y + y - 1\nmod x y            = rem x y\n\ndivMod :: Int -> Int -> (Int, Int)\ndivMod x y\n  | x > 0 && y < 0 = case (x-1) `quotRem` y of (q,r) -> (q-1, r+y+1)\n  | x < 0 && y > 1 = case (x+1) `quotRem` y of (q,r) -> (q-1, r+y-1)\ndivMod x y         = quotRem x y\n\nmin :: (Num a) => a -> a -> a\nmin = ffi \"Math.min(Fay$$_(%1),Fay$$_(%2))\"\n\nmax :: (Num a) => a -> a -> a\nmax = ffi \"Math.max(Fay$$_(%1),Fay$$_(%2))\"\n\nrecip :: Double -> Double\nrecip x = 1 / x\n\n-- | Implemented in Fay.\nnegate :: Num a => a -> a\nnegate x = (-x)\n\n-- | Implemented in Fay.\nabs :: (Num a, Ord a) => a -> a\nabs x = if x < 0 then negate x else x\n\n-- | Implemented in Fay.\nsignum :: (Num a, Ord a) => a -> a\nsignum x = if x > 0 then 1 else if x == 0 then 0 else -1\n\n-- | Uses Math.PI.\npi :: Double\npi = ffi \"Math.PI\"\n\n-- | Uses Math.exp.\nexp :: Double -> Double\nexp = ffi \"Math.exp(%1)\"\n\n-- | Uses Math.sqrt.\nsqrt :: Double -> Double\nsqrt = ffi \"Math.sqrt(%1)\"\n\n-- | Uses Math.log.\nlog :: Double -> Double\nlog = ffi \"Math.log(%1)\"\n\n-- | Uses Math.pow.\n(**) :: Double -> Double -> Double\n(**) = unsafePow\n\n-- | Uses Math.pow.\n(^^) :: Double -> Int -> Double\n(^^) = unsafePow\n\n-- | Uses Math.pow.\nunsafePow :: (Num a,Num b) => a -> b -> a\nunsafePow = ffi \"Math.pow(Fay$$_(%1),Fay$$_(%2))\"\n\n-- | Implemented in Fay, it's not fast.\n(^) :: Num a => a -> Int -> a\na ^ b | b < 0  = error \"(^): negative exponent\"\n      | b == 0 = 1\n      | even b = let x = a ^ (b `quot` 2) in x * x\na ^ b          = a * a ^ (b - 1)\n\n-- | Implemented in Fay, not fast.\nlogBase :: Double -> Double -> Double\nlogBase b x = log x / log b\n\n-- | Uses Math.sin.\nsin :: Double -> Double\nsin = ffi \"Math.sin(%1)\"\n\n-- | Uses Math.tan.\ntan :: Double -> Double\ntan = ffi \"Math.tan(%1)\"\n\n-- | Uses Math.cos.\ncos :: Double -> Double\ncos = ffi \"Math.cos(%1)\"\n\n-- | Uses Math.asin.\nasin :: Double -> Double\nasin = ffi \"Math.asin(%1)\"\n\n-- | Uses Math.atan.\natan :: Double -> Double\natan = ffi \"Math.atan(%1)\"\n\n-- | Uses Math.acos.\nacos :: Double -> Double\nacos = ffi \"Math.acos(%1)\"\n\n-- | Implemented in Fay, not fast.\nsinh :: Double -> Double\nsinh x = (exp x - exp (-x)) / 2\n\n-- | Implemented in Fay, not fast.\ntanh :: Double -> Double\ntanh x = let a = exp x ; b = exp (-x) in (a - b) / (a + b)\n\n-- | Implemented in Fay, not fast.\ncosh :: Double -> Double\ncosh x = (exp x + exp (-x)) / 2\n\n-- | Implemented in Fay, not fast.\nasinh :: Double -> Double\nasinh x = log (x + sqrt(x**2 + 1))\n\n-- | Implemented in Fay, not fast.\natanh :: Double -> Double\natanh x = log ((1 + x) / (1 - x)) / 2\n\n-- | Implemented in Fay, not fast.\nacosh :: Double -> Double\nacosh x = log (x + sqrt (x**2 - 1))\n\n-- | Implemented in Fay, not fast.\nproperFraction :: Double -> (Int, Double)\nproperFraction x = let a = truncate x in (a, x - fromIntegral a)\n\n-- | Implemented in Fay, not fast.\ntruncate :: Double -> Int\ntruncate x = if x < 0 then ceiling x else floor x\n\n-- | Uses Math.round.\nround :: Double -> Int\nround = ffi \"Math.round(%1)\"\n\n-- | Uses Math.ceil.\nceiling :: Double -> Int\nceiling = ffi \"Math.ceil(%1)\"\n\n-- | Uses Math.floor.\nfloor :: Double -> Int\nfloor = ffi \"Math.floor(%1)\"\n\n-- | Flip (-).\nsubtract :: Num a => a -> a -> a\nsubtract = flip (-)\n\n-- | Implemented in Fay, not fast.\neven :: Int -> Bool\neven x = x `rem` 2 == 0\n\n-- | not (even x)\nodd :: Int -> Bool\nodd x = not (even x)\n\n-- | Implemented in Fay, not fast.\ngcd :: Int -> Int -> Int\ngcd a b = go (abs a) (abs b)\n  where go x 0 = x\n        go x y = go y (x `rem` y)\n\n-- | Uses quot'.\nquot :: Int -> Int -> Int\nquot x y = if y == 0 then error \"Division by zero\" else quot' x y\n\n-- | Uses ~~(a/b).\nquot' :: Int -> Int -> Int\nquot' = ffi \"~~(%1/%2)\"\n\n-- | (quot x y, rem x y)\nquotRem :: Int -> Int -> (Int, Int)\nquotRem x y = (quot x y, rem x y)\n\n-- | Uses rem'.\nrem :: Int -> Int -> Int\nrem x y = if y == 0 then error \"Division by zero\" else rem' x y\n\n-- | Uses %%.\nrem' :: Int -> Int -> Int\nrem' = ffi \"%1 %% %2\"\n\nlcm :: Int -> Int -> Int\nlcm _ 0 = 0\nlcm 0 _ = 0\nlcm a b = abs ((a `quot` (gcd a b)) * b)\n\n--------------------------------------------------------------------------------\n-- Lists\n\nfind :: (a -> Bool) -> [a] -> Maybe a\nfind p (x:xs) = if p x then Just x else find p xs\nfind _ [] = Nothing\n\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter p (x:xs) = if p x then x : filter p xs else filter p xs\nfilter _ []     = []\n\nnull :: [t] -> Bool\nnull [] = True\nnull _ = False\n\nmap :: (a -> b) -> [a] -> [b]\nmap _ []     = []\nmap f (x:xs) = f x : map f xs\n\nnub :: Eq a => [a] -> [a]\nnub ls = nub' ls []\n\nnub' :: Eq a => [a] -> [a] -> [a]\nnub' []     _ = []\nnub' (x:xs) ls =\n  if elem x ls\n     then nub' xs ls\n     else x : nub' xs (x : ls)\n\nelem :: Eq a => a -> [a] -> Bool\nelem x (y:ys)   = x == y || elem x ys\nelem _ []       = False\n\nnotElem :: Eq a => a -> [a] -> Bool\nnotElem x ys = not (elem x ys)\n\nsort :: Ord a => [a] -> [a]\nsort = sortBy compare\n\nsortBy :: (t -> t -> Ordering) -> [t] -> [t]\nsortBy cmp = foldr (insertBy cmp) []\n\ninsertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]\ninsertBy _   x [] = [x]\ninsertBy cmp x ys =\n  case ys of\n    [] -> [x]\n    y:ys' ->\n      case cmp x y of\n         GT -> y : insertBy cmp x ys'\n         _  -> x : ys\n\n-- | Append two lists.\nconc :: [a] -> [a] -> [a]\nconc (x:xs) ys = x : conc xs ys\nconc []     ys = ys\n\nconcat :: [[a]] -> [a]\nconcat = foldr conc []\n\nconcatMap :: (a -> [b]) -> [a] -> [b]\nconcatMap f = foldr ((++) . f) []\n\nfoldr :: (t -> t1 -> t1) -> t1 -> [t] -> t1\nfoldr _ z []     = z\nfoldr f z (x:xs) = f x (foldr f z xs)\n\nfoldr1 :: (a -> a -> a) -> [a] -> a\nfoldr1 _ [x]    = x\nfoldr1 f (x:xs) = f x (foldr1 f xs)\nfoldr1 _ []     = error \"foldr1: empty list\"\n\nfoldl :: (t1 -> t -> t1) -> t1 -> [t] -> t1\nfoldl _ z []     = z\nfoldl f z (x:xs) = foldl f (f z x) xs\n\nfoldl1 :: (a -> a -> a) -> [a] -> a\nfoldl1 f (x:xs) = foldl f x xs\nfoldl1 _ []     = error \"foldl1: empty list\"\n\n(++) :: [a] -> [a] -> [a]\nx ++ y = conc x y\n\n(!!) :: [a] -> Int -> a\na !! b = if b < 0 then error \"(!!): negative index\" else go a b\n  where go []    _ = error \"(!!): index too large\"\n        go (h:_) 0 = h\n        go (_:t) n = go t (n-1)\n\nhead :: [a] -> a\nhead []    = error \"head: empty list\"\nhead (h:_) = h\n\ntail :: [a] -> [a]\ntail []    = error \"tail: empty list\"\ntail (_:t) = t\n\ninit :: [a] -> [a]\ninit []    = error \"init: empty list\"\ninit [_]   = []\ninit (h:t) = h : init t\n\nlast :: [a] -> a\nlast []    = error \"last: empty list\"\nlast [a]   = a\nlast (_:t) = last t\n\niterate :: (a -> a) -> a -> [a]\niterate f x = x : iterate f (f x)\n\nrepeat :: a -> [a]\nrepeat x = x : repeat x\n\nreplicate :: Int -> a -> [a]\nreplicate 0 _ = []\nreplicate n x = if n < 0 then []\n                         else x : replicate (n-1) x\n\ncycle :: [a] -> [a]\ncycle [] = error \"cycle: empty list\"\ncycle xs = xs' where xs' = xs ++ xs'\n\ntake :: Int -> [a] -> [a]\ntake 0 _  = []\ntake _ [] = []\ntake n (x:xs) = if n < 0 then []\n                         else x : take (n-1) xs\n\ndrop :: Int -> [a] -> [a]\ndrop 0 xs = xs\ndrop _ [] = []\ndrop n xss@(_:xs) = if n < 0 then xss\n                             else drop (n-1) xs\n\nsplitAt :: Int -> [a] -> ([a], [a])\nsplitAt 0 xs     = ([], xs)\nsplitAt _ []     = ([], [])\nsplitAt n (x:xs) = if n < 0 then ([],x:xs)\n                            else case splitAt (n-1) xs of (a,b) -> (x:a, b)\n\ntakeWhile :: (a -> Bool) -> [a] -> [a]\ntakeWhile _ []     = []\ntakeWhile p (x:xs) = if p x then x : takeWhile p xs else []\n\ndropWhile :: (a -> Bool) -> [a] -> [a]\ndropWhile _ []     = []\ndropWhile p (x:xs) = if p x then dropWhile p xs else x:xs\n\nspan :: (a -> Bool) -> [a] -> ([a], [a])\nspan _ []     = ([], [])\nspan p (x:xs) = if p x then case span p xs of (a,b) -> (x:a, b) else ([], x:xs)\n\nbreak :: (a -> Bool) -> [a] -> ([a], [a])\nbreak p = span (not . p)\n\nzipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith f (a:as) (b:bs) = f a b : zipWith f as bs\nzipWith _ _      _      = []\n\nzipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\nzipWith3 f (a:as) (b:bs) (c:cs) = f a b c : zipWith3 f as bs cs\nzipWith3 _ _      _      _      = []\n\nzip :: [a] -> [b] -> [(a,b)]\nzip (a:as) (b:bs) = (a,b) : zip as bs\nzip _      _      = []\n\nzip3 :: [a] -> [b] -> [c] -> [(a, b, c)]\nzip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs\nzip3 _      _      _      = []\n\nunzip :: [(a, b)] -> ([a], [b])\nunzip ((x,y):ps) = case unzip ps of (xs,ys) -> (x:xs, y:ys)\nunzip []         = ([], [])\n\nunzip3 :: [(a, b, c)] -> ([a], [b], [c])\nunzip3 ((x,y,z):ps) = case unzip3 ps of (xs,ys,zs) -> (x:xs, y:ys, z:zs)\nunzip3 []           = ([], [], [])\n\nlines :: String -> [String]\nlines []   = []\nlines s    = case break isLineBreak s of (a, [])   -> [a]\n                                         (a, _:cs) -> a : lines cs\n  where isLineBreak c = c == '\\r' || c == '\\n'\n\nunlines :: [String] -> String\nunlines [] = []\nunlines (l:ls) = l ++ '\\n' : unlines ls\n\nwords :: String -> [String]\nwords str = words' (dropWhile isSpace str)\n  where words' []  = []\n        words' s = case break isSpace s of (a,b) -> a : words b\n        isSpace c  = c `elem` \" \\t\\r\\n\\f\\v\"\n\nunwords :: [String] -> String\nunwords = intercalate \" \"\n\nand :: [Bool] -> Bool\nand []     = True\nand (x:xs) = x && and xs\n\nor :: [Bool] -> Bool\nor []     = False\nor (x:xs) = x || or xs\n\nany :: (a -> Bool) -> [a] -> Bool\nany _ []     = False\nany p (x:xs) = p x || any p xs\n\nall :: (a -> Bool) -> [a] -> Bool\nall _ []     = True\nall p (x:xs) = p x && all p xs\n\nintersperse :: a -> [a] -> [a]\nintersperse _   []      = []\nintersperse sep (x:xs)  = x : prependToAll sep xs\n\nprependToAll :: a -> [a] -> [a]\nprependToAll _   []     = []\nprependToAll sep (x:xs) = sep : x : prependToAll sep xs\n\nintercalate :: [a] -> [[a]] -> [a]\nintercalate xs xss = concat (intersperse xs xss)\n\nmaximum :: (Num a) => [a] -> a\nmaximum [] = error \"maximum: empty list\"\nmaximum xs = foldl1 max xs\n\nminimum :: (Num a) => [a] -> a\nminimum [] = error \"minimum: empty list\"\nminimum xs = foldl1 min xs\n\nproduct :: Num a => [a] -> a\nproduct xs = foldl (*) 1 xs\n\nsum :: Num a => [a] -> a\nsum xs = foldl (+) 0 xs\n\nscanl :: (a -> b -> a) -> a -> [b] -> [a]\nscanl f z l = z : case l of [] -> []\n                            (x:xs) -> scanl f (f z x) xs\n\nscanl1 :: (a -> a -> a) -> [a] -> [a]\nscanl1 _ [] = []\nscanl1 f (x:xs) = scanl f x xs\n\nscanr :: (a -> b -> b) -> b -> [a] -> [b]\nscanr _ z [] = [z]\nscanr f z (x:xs) = case scanr f z xs of (h:t) -> f x h : h : t\n                                        _     -> undefined\n\nscanr1 :: (a -> a -> a) -> [a] -> [a]\nscanr1 _ []     = []\nscanr1 _ [x]    = [x]\nscanr1 f (x:xs) = case scanr1 f xs of (h:t) -> f x h : h : t\n                                      _     -> undefined\n\nlookup :: Eq a1 => a1 -> [(a1, a)] -> Maybe a\nlookup _key []          =  Nothing\nlookup  key ((x,y):xys) =\n  if key == x\n     then Just y\n     else lookup key xys\n\nlength :: [a] -> Int\nlength xs = length' 0 xs\n\nlength' :: Int -> [a] -> Int\nlength' acc (_:xs) = length' (acc+1) xs\nlength' acc _ = acc\n\nreverse :: [a] -> [a]\nreverse (x:xs) = reverse xs ++ [x]\nreverse [] = []\n\n--------------------------------------------------------------------------------\n-- IO\n\nprint :: Automatic a -> Fay ()\nprint = ffi \"(function(x) { if (console && console.log) console.log(x) })(%1)\"\n\nputStrLn :: String -> Fay ()\nputStrLn = ffi \"(function(x) { if (console && console.log) console.log(x) })(%1)\"\n\n--------------------------------------------------------------------------------\n-- Additions\n\n-- | Default definition for using RebindableSyntax.\nifThenElse :: Bool -> t -> t -> t\nifThenElse p a b = if p then a else b\n") 
  go _ (ModuleName _ "Marlowe") = return ("Marlowe.hs", "module Marlowe(Money(..), Observation(..), Contract(..), Person, Random, BlockNumber, Cash, ConcreteChoice, Timeout, IdentCC(..), IdentChoice(..), IdentPay(..), prettyPrintContract) where\n\n-- Standard library functions\n\ngroupBy                 :: (a -> a -> Bool) -> [a] -> [[a]]\ngroupBy _  []           =  []\ngroupBy eq (x:xs)       =  (x:ys) : groupBy eq zs\n                           where (ys,zs) = span (eq x) xs\n\n -- People are represented by their public keys,\n -- which in turn are given by integers.\n\ntype Key         = Int   -- Public key\ntype Person      = Key\n\n-- Block numbers and random numbers are both integers.\n \ntype Random      = Int\ntype BlockNumber = Int\n\n-- Observables are things which are recorded on the blockchain.\n--  e.g. \"a random choice\", the value of GBP/BTC exchange rate, \8230\n\n-- Question: how do we implement these things?\n--  - We assume that some mechanism exists which will ensure that the value is looked up and recorded, or \8230\n--  - \8230 we actually provide that mechanism explicitly, e.g. with inter-contract comms or transaction generation or something.\n\n-- Other observables are possible, e.g. the value of the oil price at this time.\n-- It is assumed that these would be provided in some agreed way by an oracle of some sort.\n\n-- The Observable data type represents the different sorts of observables, \8230\n\ndata Observable = Random | BlockNumber\n                    deriving (Eq)\n\nshowObservable Random = \"Random\"\nshowObservable BlockNumber = \"BlockNumber\"\n\n-- Inputs\n-- Types for cash commits, money redeems, and choices.\n--\n-- A cash commitment is an integer (should be positive integer?)\n-- Concrete values are sometimes chosen too: these are integers for the sake of this model.\n\ntype Cash     = Int\ntype ConcreteChoice = Int\n\n-- We need to put timeouts on various operations. These could be some abstract time\n-- domain, but it only really makes sense for these to be block numbers.\n\ntype Timeout = BlockNumber\n\n-- Commitments, choices and payments are all identified by identifiers.\n-- Their types are given here. In a more sophisticated model these would\n-- be generated automatically (and so uniquely); here we simply assume that \n-- they are unique.\n\nnewtype IdentCC = IdentCC Int\n               deriving (Eq)\n\nnewtype IdentChoice = IdentChoice Int\n               deriving (Eq)\n\nnewtype IdentPay = IdentPay Int\n               deriving (Eq)\n\n-- Money is a set of contract primitives that represent constants,\n-- functions, and variables that can be evaluated as an ammount\n-- of money.\n\ndata Money = AvailableMoney IdentCC |\n             AddMoney Money Money |\n             ConstMoney Cash |\n             MoneyFromChoice IdentChoice Person Money\n                    deriving (Eq)\n\nshowMoney :: Money -> String\nshowMoney (AvailableMoney (IdentCC icc)) = \"(AvailableMoney (IdentCC \" ++ show icc ++ \"))\"\nshowMoney (AddMoney m1 m2) = \"(AddMoney \" ++ showMoney m1 ++ \" \" ++ showMoney m2 ++ \")\"\nshowMoney (ConstMoney cash) = \"(ConstMoney \" ++ show cash ++ \")\"\nshowMoney (MoneyFromChoice (IdentChoice ic) p m) = \"(MoneyFromChoice (IdentChoice \" ++ show ic ++ \") \" ++ show p ++ \" \" ++ showMoney m ++ \")\"\n\n-- Representation of observations over observables and the state.\n-- Rendered into predicates by interpretObs.\n\ndata Observation =  BelowTimeout Timeout | -- are we still on time for something that expires on Timeout?\n                    AndObs Observation Observation |\n                    OrObs Observation Observation |\n                    NotObs Observation |\n                    PersonChoseThis IdentChoice Person ConcreteChoice |\n                    PersonChoseSomething IdentChoice Person |\n                    ValueGE Money Money | -- is first ammount is greater or equal than the second?\n                    TrueObs | FalseObs\n                    deriving (Eq)\n\nshowObservation :: Observation -> String\nshowObservation (BelowTimeout tim) = \"(BelowTimeout \" ++ (show tim) ++ \")\"\nshowObservation (AndObs obs1 obs2) = \"(AndObs \" ++ (showObservation obs1) ++ \" \" ++ (showObservation obs2) ++ \")\"\nshowObservation (OrObs obs1 obs2) = \"(OrObs \" ++ (showObservation obs1) ++ \" \" ++ (showObservation obs2) ++ \")\"\nshowObservation (NotObs obs) = \"(NotObs \" ++ (showObservation obs) ++ \")\"\nshowObservation (PersonChoseThis (IdentChoice ic) per cho) = \"(PersonChoseThis (IdentChoice \" ++ (show ic) ++ \") \" ++ (show per) ++ \" \" ++ (show cho) ++ \")\"\nshowObservation (PersonChoseSomething (IdentChoice ic) per) = \"(PersonChoseSomething (IdentChoice \" ++ (show ic) ++ \") \" ++ (show per) ++ \")\"\nshowObservation (ValueGE m1 m2) = \"(ValueGE \" ++ (showMoney m1) ++ \" \" ++ (showMoney m2) ++ \")\"\nshowObservation TrueObs = \"TrueObs\"\nshowObservation FalseObs = \"FalseObs\"\n \n-- The type of contracts\n\ndata Contract =\n    Null |\n    CommitCash IdentCC Person Money Timeout Timeout Contract Contract |\n    RedeemCC IdentCC Contract |\n    Pay IdentPay Person Person Money Timeout Contract |\n    Both Contract Contract |\n    Choice Observation Contract Contract |\n    When Observation Timeout Contract Contract\n               deriving (Eq)\n\nshowContract Null = \"Null\"\nshowContract (CommitCash (IdentCC idc) per mon tim1 tim2 con1 con2) = \"(CommitCash (IdentCC \" ++ (show idc) ++ \") \" ++ (show per) ++ \" \" ++ (showMoney mon) ++ \" \" ++ (show tim1) ++ \" \" ++ (show tim2) ++ \" \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\nshowContract (RedeemCC (IdentCC idc) con) = \"(RedeemCC (IdentCC \" ++ (show idc) ++ \") \" ++ (showContract con) ++ \")\"\nshowContract (Pay (IdentPay idp) per1 per2 mon tim con) = \"(Pay (IdentPay \" ++ (show idp) ++ \") \" ++ (show per1) ++ \" \" ++ (show per2) ++ \" \" ++ (showMoney mon) ++ \" \" ++ (show tim) ++ \" \" ++ (showContract con) ++ \")\"\nshowContract (Both con1 con2) = \"(Both \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\nshowContract (Choice obs con1 con2) = \"(Choice \" ++ (showObservation obs) ++ \" \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\nshowContract (When obs tim con1 con2) = \"(When \" ++ (showObservation obs) ++ \" \" ++ (show tim) ++ \" \" ++ (showContract con1) ++ \" \" ++ (showContract con2) ++ \")\"\n \n\n------------------------\n-- AST dependent code --\n------------------------\n\ndata ASTNode = ASTNodeC Contract\n             | ASTNodeO Observation\n             | ASTNodeM Money\n             | ASTNodeCC IdentCC\n             | ASTNodeIC IdentChoice\n             | ASTNodeIP IdentPay\n             | ASTNodeI Int\n\nlistCurryType :: ASTNode -> (String, [ASTNode])\nlistCurryType (ASTNodeM (AvailableMoney identCC))\n = (\"AvailableMoney\", [ASTNodeCC identCC])\nlistCurryType (ASTNodeM (AddMoney money1 money2))\n = (\"AddMoney\", [ASTNodeM money1, ASTNodeM money2])\nlistCurryType (ASTNodeM (ConstMoney cash))\n = (\"ConstMoney\", [ASTNodeI cash])\nlistCurryType (ASTNodeM (MoneyFromChoice identChoice person def))\n = (\"MoneyFromChoice\", [ASTNodeIC identChoice, ASTNodeI person, ASTNodeM def])\nlistCurryType (ASTNodeO (BelowTimeout timeout))\n = (\"BelowTimeout\", [ASTNodeI timeout])\nlistCurryType (ASTNodeO (AndObs observation1 observation2))\n = (\"AndObs\", [ASTNodeO observation1, ASTNodeO observation2])\nlistCurryType (ASTNodeO (OrObs observation1 observation2))\n = (\"OrObs\", [ASTNodeO observation1, ASTNodeO observation2])\nlistCurryType (ASTNodeO (NotObs observation))\n = (\"NotObs\", [ASTNodeO observation])\nlistCurryType (ASTNodeO (PersonChoseThis identChoice person concreteChoice))\n = (\"PersonChoseThis\", [ASTNodeIC identChoice, ASTNodeI person, ASTNodeI concreteChoice])\nlistCurryType (ASTNodeO (PersonChoseSomething identChoice person))\n = (\"PersonChoseSomething\", [ASTNodeIC identChoice, ASTNodeI person])\nlistCurryType (ASTNodeO (ValueGE money1 money2))\n = (\"ValueGE\", [ASTNodeM money1, ASTNodeM money2])\nlistCurryType (ASTNodeO TrueObs) = (\"TrueObs\", [])\nlistCurryType (ASTNodeO FalseObs) = (\"FalseObs\", [])\nlistCurryType (ASTNodeC Null) = (\"Null\", [])\nlistCurryType (ASTNodeC (CommitCash identCC person cash timeout1 timeout2 contract1 contract2))\n = (\"CommitCash\", [ASTNodeCC identCC, ASTNodeI person, ASTNodeM cash, ASTNodeI timeout1,\n                   ASTNodeI timeout2, ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeC (RedeemCC identCC contract))\n = (\"RedeemCC\", [ASTNodeCC identCC, ASTNodeC contract])\nlistCurryType (ASTNodeC (Pay identPay person1 person2 cash timeout contract))\n = (\"Pay\", [ASTNodeIP identPay, ASTNodeI person1, ASTNodeI person2,\n            ASTNodeM cash, ASTNodeI timeout, ASTNodeC contract])\nlistCurryType (ASTNodeC (Both contract1 contract2))\n = (\"Both\", [ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeC (Choice observation contract1 contract2))\n = (\"Choice\", [ASTNodeO observation, ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeC (When observation timeout contract1 contract2))\n = (\"When\", [ASTNodeO observation, ASTNodeI timeout, ASTNodeC contract1, ASTNodeC contract2])\nlistCurryType (ASTNodeCC (IdentCC int)) = (\"IdentCC\", [ASTNodeI int])\nlistCurryType (ASTNodeIC (IdentChoice int)) = (\"IdentChoice\", [ASTNodeI int])\nlistCurryType (ASTNodeIP (IdentPay int)) = (\"IdentPay\", [ASTNodeI int])\nlistCurryType (ASTNodeI int) = (show int, [])\n\nisComplex :: ASTNode -> Bool\nisComplex (ASTNodeO _) = True\nisComplex (ASTNodeC _) = True\nisComplex (ASTNodeM _) = True\nisComplex _ = False\n\n--------------------------\n-- AST independent code --\n--------------------------\n\ndata NodeType = Trivial (String, [ASTNode])\n              | Simple (String, [ASTNode])\n              | Complex (String, [ASTNode])\n\ntabulateLine :: Int -> String\ntabulateLine n = replicate n ' '\n\nclassify :: ASTNode -> NodeType\nclassify x\n  | null $ snd r = Trivial r\n  | isComplex x = Complex r\n  | otherwise = Simple r\n  where r = listCurryType x\n\nisTrivial :: NodeType -> Bool\nisTrivial (Trivial _) = True\nisTrivial _ = False\n\nnoneComplex :: NodeType -> NodeType -> Bool\nnoneComplex (Complex _) _ = False\nnoneComplex _ (Complex _)= False\nnoneComplex _ _ = True\n\n-- We assume that Simple nodes have Simple or Trivial children\nsmartPrettyPrint :: Int -> NodeType -> String\nsmartPrettyPrint _ (Trivial a) = prettyPrint 0 a\nsmartPrettyPrint _ (Simple a) = \"(\" ++ prettyPrint 0 a ++ \")\"\nsmartPrettyPrint spaces (Complex a) = \"(\" ++ prettyPrint (spaces + 1) a ++ \")\"\n\nprettyPrint :: Int -> (String, [ASTNode]) -> String\nprettyPrint _ (name, []) = name\nprettyPrint spaces (name, args) = intercalate \"\\n\" (trivialNames : map (tabulateLine newSpaces ++) others)\n  where\n    classified = map classify args\n    newSpaces = spaces + length name + 1\n    groupedClassified = groupBy noneComplex classified\n    trivialNames = unwords (name : map (smartPrettyPrint newSpaces) (head groupedClassified))\n    others = map (unwords . map (smartPrettyPrint newSpaces)) (tail groupedClassified)\n\n-------------\n-- Wrapper --\n-------------\n\nprettyPrintContract :: Contract -> String\nprettyPrintContract = prettyPrint 0 . listCurryType . ASTNodeC\n\n")
  go (dir:dirs) name = do
    exists <- io (doesFileExist path)
    if exists
           then (path,) . stdlibHack <$> io (readFile path)
           else go dirs name
    where
      path = dir </> replace '.' '/' (prettyPrint name) ++ ".hs"
      stdlibHack = case mname of
                     ModuleName _ "Fay.FFI" -> const "module Fay.FFI where\n\ndata Nullable a = Nullable a | Null\n\ndata Defined a = Defined a | Undefined"
                     _ -> id 
      replace c r = map (\x -> if x == c then r else x)
  go [] name = throwError $ Couldn'tFindImport (unAnn name) alldirs


